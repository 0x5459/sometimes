package vm

import (
	"errors"
	"sometimes/ir/value"
)

// Pointer type is int alias.
type Ptr = int

// Frame represents a call frame.
type Frame struct {
	RetAddr Ptr // instruction Pointer
}

var StackOverflow = errors.New("stack overflow")

// Operand stack type
type OperandStack = Stack[value.Value]


// Call frames stack
type FrameStack = Stack[Frame]

type Stack[T any] struct {
	inner []T
	top   int // stack top pointer
	cap   int
}

// NewOperandStack returns a new OperandStack.
func NewOperandStack(cap int) *Stack[value.Value] {
	return NewStack[value.Value](cap);
}

// NewFrameStack returns a new FrameStack.
func NewFrameStack(cap int) *Stack[Frame] {
	return NewStack[Frame](cap);
}


// NewStack returns a new Stack.
func NewStack[T any](cap int) *Stack[T] {
	return &Stack[T]{
		inner: make([]T, 0, cap>>2),
		top:   0,
		cap:   cap,
	}
}

// Push appends an element to the back of a stack.
// or panic if the stack is full.
func (s *Stack[T]) Push(v T) {
	if s.top == s.cap {
		panic(StackOverflow)
	}
	s.inner = append(s.inner, v)
	s.top++
}

// Pop removes the last element from a stack and returns it,
// or panic if it is empty.
func (s *Stack[T]) Pop() T {
	return s.PopN(1)
}

// PopN removes the last n elements from a stack and returns the last removed element,
// or panic if it is empty.
func (s *Stack[T]) PopN(n int) T {
	if s.top < n {
		panic(StackOverflow)
	}
	// 考虑缩容问题
	s.top -= n
	return s.inner[s.top]
}

func (s *Stack[T]) IsEmpty() bool {
	return s.top == 0
}
