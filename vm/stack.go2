package vm

import (
	"errors"
)

// Pointer type is int alias.
type Ptr = int

// Frame represents a call frame.
type Frame struct {
	RetAddr Ptr // instruction Pointer
}

var StackOverflow = errors.New("stack overflow")

// vm stack type
type VMStack Stack[uint]


// Call frames stack
type FrameStack Stack[Frame]

type Stack[T any] struct {
	inner []T
	top   int // stack top pointer
	cap   int
}

// NewVMStack returns a new VMStack.
func NewVMStack(cap int) *Stack[uint] {
	return NewStack[uint](cap);
}

// NewFrameStack returns a new FrameStack.
func NewFrameStack(cap int) *Stack[Frame] {
	return NewStack[Frame](cap);
}


// NewStack returns a new Stack.
func NewStack[T any](cap int) *Stack[T] {
	return &Stack[T]{
		inner: make([]T, 0, cap>>2),
		top:   0,
		cap:   cap,
	}
}

// Push appends an element to the back of a stack.
// or panic if the stack is full.
func (s *Stack[T]) Push(v T) {
	if s.top == s.cap {
		panic(StackOverflow)
	}
	s.inner = append(s.inner, v)
	s.top++
}

// Pop removes the last element from a stack and returns it,
// or panic if it is empty.
func (s *Stack[T]) Pop() T {
	return s.PopN(1)
}

// PopN removes the last n elements from a stack and returns the last removed element,
// or panic if it is empty.
func (s *Stack[T]) PopN(n int) T {
	if s.top < n {
		panic(StackOverflow)
	}
	s.top -= n
	return s.inner[s.top]
}
